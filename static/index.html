<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slurm Job Monitor</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Vue.js -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            padding: 20px;
        }
        .container {
            max-width: none;
            width: 100%;
            margin: 0 auto;
        }
        .header {
            margin-bottom: 30px;
        }
        .status-badge {
            font-size: 0.85em;
            padding: 0.35em 0.65em;
        }
        .table-responsive {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .last-updated {
            color: #6c757d;
            font-size: 0.9em;
            margin-bottom: 15px;
        }
        .refresh-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #28a745;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .comment-cell {
            min-width: 240px;
            max-width: 240px;
        }
        .comment-display {
            min-height: 60px;
        }
        .comment-text {
            flex: 1;
            min-width: 0;
            word-break: break-word;
            white-space: pre-wrap;
        }
        .comment-editor textarea {
            font-size: 0.85rem;
        }
        .job-name-cell {
            min-width: 240px;
            max-width: 320px;
        }
        .info-table td {
            vertical-align: top;
            word-break: break-word;
        }
        .search-card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            padding: 16px;
            margin-bottom: 24px;
        }
        .search-results {
            max-height: 260px;
            overflow-y: auto;
        }
        .search-result-item {
            border-bottom: 1px solid #e9ecef;
            padding: 10px 0;
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .log-container {
            background-color: #1e1e1e;
            color: #c9f2c7;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
            position: relative;
        }
        .log-output-wrapper {
            position: relative;
            background-color: #111;
            border-radius: 4px;
            overflow: hidden;
        }
        .log-output {
            background-color: #111;
            border-radius: 4px;
            height: 320px;
            overflow-y: auto;
            margin-bottom: 0;
            resize: vertical;
            min-height: 150px;
            max-height: 800px;
            padding: 0;
        }
        .log-chunk {
            margin: 0;
            font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            padding: 12px;
            white-space: pre-wrap;
        }
        .resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            background-color: #333;
            cursor: ns-resize;
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .resize-handle:hover {
            background-color: #444;
        }
        .resize-handle::after {
            content: '⋮';
            color: #888;
            font-size: 12px;
            line-height: 1;
        }
        .log-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        .log-toolbar small {
            color: #9cc09a;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="d-flex flex-column flex-lg-row align-items-start align-items-lg-center justify-content-between gap-3 mb-4">
                <div class="header m-0">
                    <h2 class="h4 mb-2 mb-lg-0 text-uppercase text-muted">Slurm Job Monitor</h2>
                    <div class="last-updated">
                        <span class="refresh-indicator"></span>
                        <span>Auto-refreshing every 2 seconds</span>
                        <span v-if="lastUpdate"> | Last updated: {{ lastUpdate }}</span>
                    </div>
                </div>
                <div class="search-card w-100 w-lg-auto">
                    <div class="d-flex flex-column flex-md-row gap-2 align-items-stretch">
                        <input
                            type="text"
                            class="form-control"
                            placeholder="Search logs by job ID or filename"
                            v-model="searchQuery"
                            @input="onSearchInput"
                            @keyup.enter="searchLogs"
                        >
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary" :disabled="searchLoading" @click="searchLogs">
                                <span v-if="searchLoading" class="spinner-border spinner-border-sm" role="status"></span>
                                <span v-else>Search</span>
                            </button>
                            <button class="btn btn-outline-secondary" :disabled="searchLoading && !searchResults.length" @click="clearSearch">
                                Clear
                            </button>
                        </div>
                    </div>
                    <div class="text-muted small mt-2 d-flex flex-wrap gap-3">
                        <span>Directory: {{ outputDir || 'Not configured' }}</span>
                        <span>Matches: {{ searchResults.length }}</span>
                    </div>
                    <div v-if="searchError" class="alert alert-warning py-2 mt-2">
                        {{ searchError }}
                    </div>
                    <div v-if="searchResults.length" class="search-results mt-3">
                        <div
                            class="search-result-item d-flex flex-column flex-md-row gap-2 align-items-start align-items-md-center"
                            v-for="result in searchResults"
                            :key="result.relative_path"
                        >
                            <div class="flex-grow-1 w-100">
                                <div class="d-flex flex-wrap align-items-center gap-2">
                                    <strong>{{ result.filename }}</strong>
                                    <span class="text-muted small">• {{ formatBytes(result.size_bytes) }}</span>
                                    <span class="text-muted small">• {{ formatDate(result.modified) }}</span>
                                    <span class="text-muted small text-break">• {{ result.path || getResultFullPath(result) }}</span>
                                </div>
                                <div class="text-muted small mt-1" v-if="result.job_id || result.comment">
                                    <span v-if="result.job_id">Job {{ result.job_id }}</span>
                                    <span v-if="result.comment">
                                        • {{ result.comment }}
                                    </span>
                                </div>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-primary" @click="openSearchResult(result)">
                                    Open log
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="d-flex flex-wrap gap-2 align-items-center mb-3">
                <button
                    class="btn btn-outline-success"
                    :disabled="completedLoading"
                    @click="toggleCompletedJobs"
                >
                    <span v-if="completedLoading" class="spinner-border spinner-border-sm me-2"></span>
                    <span v-if="completedVisible">Hide completed jobs</span>
                    <span v-else>Show completed jobs</span>
                </button>
                <button
                    class="btn btn-outline-danger"
                    :disabled="failedLoading"
                    @click="toggleFailedJobs"
                >
                    <span v-if="failedLoading" class="spinner-border spinner-border-sm me-2"></span>
                    <span v-if="failedVisible">Hide failed jobs</span>
                    <span v-else>Show failed jobs</span>
                </button>
                <small v-if="failedVisible && failedLastFetched" class="text-muted">
                    Last refreshed: {{ failedLastFetched }}
                </small>
            </div>
            <div v-if="completedVisible" class="search-card w-100 mb-4">
                <div class="d-flex flex-wrap gap-2 align-items-center mb-3">
                    <strong class="me-auto">Recently Completed Jobs</strong>
                    <div class="d-flex align-items-center gap-2">
                        <label class="small text-muted mb-0">Lookback</label>
                        <select
                            class="form-select form-select-sm"
                            style="width: auto;"
                            v-model.number="completedHours"
                            @change="fetchCompletedJobs"
                        >
                            <option :value="24">24 hours</option>
                            <option :value="72">3 days</option>
                            <option :value="168">7 days</option>
                        </select>
                    </div>
                    <button class="btn btn-sm btn-outline-primary" :disabled="completedLoading" @click="fetchCompletedJobs">
                        <span v-if="completedLoading" class="spinner-border spinner-border-sm me-2"></span>
                        Refresh
                    </button>
                </div>
                <div v-if="completedError" class="alert alert-warning py-2">{{ completedError }}</div>
                <div class="table-responsive" style="max-height: 320px;">
                    <table class="table table-sm table-hover mb-0">
                        <thead class="table-light">
                            <tr>
                                <th>Job ID</th>
                                <th>Name</th>
                                <th>Completed</th>
                                <th>Comment</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-if="!completedJobs.length && !completedLoading">
                                <td colspan="4" class="text-muted text-center py-3">
                                    No completed jobs found in the selected window.
                                </td>
                            </tr>
                            <tr v-for="job in completedJobs" :key="job.JOBID">
                                <td><code>{{ job.JOBID }}</code></td>
                                <td>
                                    <div class="fw-semibold">{{ job.NAME || '-' }}</div>
                                </td>
                                <td>
                                    <small class="text-muted" v-if="job.END_TIME">{{ formatDate(job.END_TIME) }}</small>
                                </td>
                                <td>
                                    <small v-if="job.comment">{{ job.comment }}</small>
                                    <small v-else class="text-muted">—</small>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div v-if="failedVisible" class="search-card w-100 mb-4">
                <div class="d-flex flex-wrap gap-2 align-items-center mb-3">
                    <strong class="me-auto">Recently Failed Jobs</strong>
                    <div class="d-flex align-items-center gap-2">
                        <label class="small text-muted mb-0">Lookback</label>
                        <select
                            class="form-select form-select-sm"
                            style="width: auto;"
                            v-model.number="failedHours"
                            @change="fetchFailedJobs"
                        >
                            <option :value="24">24 hours</option>
                            <option :value="72">3 days</option>
                            <option :value="168">7 days</option>
                        </select>
                    </div>
                    <button class="btn btn-sm btn-outline-primary" :disabled="failedLoading" @click="fetchFailedJobs">
                        <span v-if="failedLoading" class="spinner-border spinner-border-sm me-2"></span>
                        Refresh
                    </button>
                </div>
                <div v-if="failedError" class="alert alert-warning py-2">{{ failedError }}</div>
                <div class="table-responsive" style="max-height: 320px;">
                    <table class="table table-sm table-hover mb-0">
                        <thead class="table-light">
                            <tr>
                                <th>Job ID</th>
                                <th>Name</th>
                                <th>Comment</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-if="!failedJobs.length && !failedLoading">
                                <td colspan="3" class="text-muted text-center py-3">
                                    No failed jobs found in the selected window.
                                </td>
                            </tr>
                            <tr v-for="job in failedJobs" :key="job.JOBID">
                                <td><code>{{ job.JOBID }}</code></td>
                                <td>
                                    <div class="fw-semibold">{{ job.NAME || '-' }}</div>
                                    <small class="text-muted" v-if="job.END_TIME">{{ formatDate(job.END_TIME) }}</small>
                                </td>
                                <td>
                                    <small v-if="job.comment">{{ job.comment }}</small>
                                    <small v-else class="text-muted">—</small>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div v-if="searchLogState.visible" class="log-container mb-4">
                <div class="log-toolbar">
                    <div>
                        <strong>Historical Log</strong>
                        <small class="d-block text-muted">{{ searchLogState.path }}</small>
                        <small class="d-block text-muted" v-if="searchLogState.jobId">
                            Job {{ searchLogState.jobId }}
                            <span v-if="searchLogState.jobComment">• {{ searchLogState.jobComment }}</span>
                        </small>
                    </div>
                    <div class="d-flex align-items-center gap-3">
                        <span v-if="searchLogState.loading" class="text-warning">
                            <span class="spinner-border spinner-border-sm"></span>
                            <span class="ms-2">Loading log…</span>
                        </span>
                        <small v-if="searchLogState.chunkBytes" class="text-muted">
                            Chunk size {{ formatBytes(searchLogState.chunkBytes) }}
                        </small>
                        <button class="btn btn-sm btn-outline-light" @click="closeSearchLog">
                            Close
                        </button>
                    </div>
                </div>
                <div
                    class="d-flex justify-content-between align-items-center text-muted small mb-2 flex-wrap gap-2"
                    v-if="getSearchLogRange()"
                >
                    <span>
                        Showing {{ formatBytes(getSearchLogRange().shown) }}
                        <span v-if="getSearchLogRange().size">of {{ formatBytes(getSearchLogRange().size) }}</span>
                    </span>
                    <div class="d-flex gap-2">
                        <button
                            class="btn btn-link btn-sm p-0"
                            v-if="searchLogState.hasPrev"
                            :disabled="searchLogState.loading"
                            @click="loadMoreSearchLog('prev')"
                        >
                            Load previous
                        </button>
                        <button
                            class="btn btn-link btn-sm p-0"
                            v-if="searchLogState.hasNext"
                            :disabled="searchLogState.loading"
                            @click="loadMoreSearchLog('next')"
                        >
                            Load next
                        </button>
                        <button
                            class="btn btn-link btn-sm p-0"
                            :disabled="searchLogState.loading"
                            @click="scrollToSearchTop"
                        >
                            Go to top
                        </button>
                    </div>
                </div>
                <div class="log-output-wrapper">
                    <div class="log-output" ref="searchLogOutput" @scroll="handleSearchLogScroll">
                        <div :style="{height: getSearchSpacer().top + 'px'}"></div>
                        <pre class="log-chunk">{{ getSearchLogText() || 'No content loaded yet.' }}</pre>
                        <div :style="{height: getSearchSpacer().bottom + 'px'}"></div>
                    </div>
                </div>
            </div>

            <div v-if="error" class="alert alert-danger" role="alert">
                <strong>Error:</strong> {{ error }}
            </div>
            <div v-if="statusMessage" class="alert alert-success alert-dismissible fade show" role="alert">
                {{ statusMessage }}
                <button type="button" class="btn-close" aria-label="Close" @click="statusMessage = null"></button>
            </div>
            <div v-if="searchLogState.error" class="alert alert-warning py-2">
                {{ searchLogState.error }}
            </div>

            <div v-if="loading && jobs.length === 0" class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3">Loading jobs...</p>
            </div>

            <div v-else class="table-responsive">
                <table class="table table-hover table-striped mb-0">
                    <thead class="table-dark">
                        <tr>
                            <th>Job ID</th>
                            <th>Partition</th>
                            <th class="job-name-cell">Name</th>
                            <th>Status</th>
                            <th>Time</th>
                            <th>Nodes</th>
                            <th>Node</th>
                            <th>Time Limit</th>
                            <th>Start Time</th>
                            <th>Submit Time</th>
                            <th>Comment</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-if="jobs.length === 0 && !loading">
                            <td colspan="12" class="text-center text-muted py-4">
                                No jobs found
                            </td>
                        </tr>
                        <template v-for="job in jobs" :key="job && job['JOBID'] ? job['JOBID'] : Math.random()">
                            <tr v-if="job">
                                <td><code>{{ job['JOBID'] || '-' }}</code></td>
                                <td>{{ job['PARTITION'] || '-' }}</td>
                                <td class="job-name-cell"><strong>{{ job['NAME'] || '-' }}</strong></td>
                                <td>
                                    <span :class="getStatusBadgeClass(job['STATE'] || '')" class="badge status-badge">
                                        {{ job['STATE'] || '-' }}
                                    </span>
                                </td>
                                <td>{{ job['TIME'] || '-' }}</td>
                                <td>{{ job['NODES'] || '-' }}</td>
                                <td><small>{{ job['REASON'] || '-' }}</small></td>
                                <td>{{ job['TIME_LIMIT'] || '-' }}</td>
                                <td><small>{{ job['START_TIME'] || '-' }}</small></td>
                                <td><small>{{ job['SUBMIT_TIME'] || '-' }}</small></td>
                                <td class="comment-cell align-top">
                                    <div
                                        v-if="job['JOBID'] && !isEditingComment(job['JOBID'])"
                                        class="comment-display d-flex align-items-start gap-2"
                                    >
                                        <div class="comment-text">
                                            <small v-if="job['comment']" class="text-body">{{ job['comment'] }}</small>
                                            <small v-else class="text-muted"> </small>
                                        </div>
                                        <button
                                            class="btn btn-sm btn-outline-secondary"
                                            :disabled="!job['JOBID']"
                                            @click="startEditingComment(job)"
                                        >
                                            Edit
                                        </button>
                                    </div>
                                    <div v-else-if="job['JOBID']" class="comment-editor">
                                        <textarea
                                            class="form-control form-control-sm"
                                            rows="2"
                                            v-model="commentDrafts[job['JOBID']]"
                                            placeholder="Enter a note for this job"
                                        ></textarea>
                                        <div class="mt-2 d-flex gap-2">
                                            <button
                                                class="btn btn-sm btn-primary"
                                                :disabled="commentSaving[job['JOBID']]"
                                                @click="saveComment(job)"
                                            >
                                                <span v-if="commentSaving[job['JOBID']]">Saving…</span>
                                                <span v-else>Save</span>
                                            </button>
                                            <button
                                                class="btn btn-sm btn-outline-secondary"
                                                :disabled="commentSaving[job['JOBID']]"
                                                @click="cancelEditingComment(job['JOBID'])"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    </div>
                                </td>
                                <td>
                                    <button
                                        class="btn btn-sm btn-outline-primary me-2"
                                        :disabled="!job['JOBID']"
                                        @click="toggleLog(job)"
                                    >
                                        <span v-if="job['JOBID'] && getLogState(job['JOBID']).visible">Hide Log</span>
                                        <span v-else>View Log</span>
                                    </button>
                                    <button
                                        class="btn btn-sm btn-outline-secondary me-2"
                                        :disabled="!job['JOBID']"
                                        @click="toggleScript(job)"
                                    >
                                        <span v-if="job['JOBID'] && getScriptState(job['JOBID']).visible">Hide Script</span>
                                        <span v-else>Script</span>
                                    </button>
                                    <button
                                        class="btn btn-sm btn-outline-info me-2"
                                        :disabled="!job['JOBID']"
                                        @click="toggleInfo(job)"
                                    >
                                        <span v-if="job['JOBID'] && getInfoState(job['JOBID']).visible">Hide Info</span>
                                        <span v-else>Info</span>
                                    </button>
                                    <button
                                        class="btn btn-sm btn-outline-danger"
                                        :disabled="!canCancel(job) || (job['JOBID'] && cancelingJobs[job['JOBID']])"
                                        @click="cancelJob(job)"
                                    >
                                        <span v-if="job['JOBID'] && cancelingJobs[job['JOBID']]">Cancelling...</span>
                                        <span v-else>Cancel</span>
                                    </button>
                                </td>
                            </tr>
                            <tr v-if="job && job['JOBID'] && getLogState(job['JOBID']).visible">
                                <td colspan="12">
                                    <div class="log-container">
                                        <div class="log-toolbar">
                                            <div>
                                                <strong>Log for job {{ job['JOBID'] }}</strong>
                                                <small v-if="getLogState(job['JOBID']).path" class="ms-2">
                                                    {{ getLogState(job['JOBID']).path }}
                                                </small>
                                            </div>
                                            <div class="d-flex align-items-center gap-3 flex-wrap justify-content-end">
                                                <div v-if="getLogState(job['JOBID']).loading" class="text-warning">
                                                    <span class="spinner-border spinner-border-sm" role="status"></span>
                                                    <span class="ms-2">Refreshing…</span>
                                                </div>
                                                <div v-else class="text-end">
                                                    <small v-if="getLogState(job['JOBID']).lastFetched" class="d-block">
                                                        Last updated: {{ getLogState(job['JOBID']).lastFetched }}
                                                    </small>
                                                <small class="text-muted d-block" v-if="getLogState(job['JOBID']).chunkBytes">
                                                    Chunk size {{ formatBytes(getLogState(job['JOBID']).chunkBytes) }}
                                                </small>
                                                </div>
                                                <button class="btn btn-sm btn-outline-light" @click="refreshLog(job['JOBID'])">
                                                    Refresh now
                                                </button>
                                            </div>
                                        </div>
                                        <div
                                            class="d-flex justify-content-between align-items-center text-muted small mb-2 flex-wrap gap-2"
                                            v-if="getLogRange(job['JOBID'])"
                                        >
                                            <span>
                                                Showing {{ formatBytes(getLogRange(job['JOBID']).shown) }}
                                                <span v-if="getLogRange(job['JOBID']).size">
                                                    of {{ formatBytes(getLogRange(job['JOBID']).size) }}
                                                </span>
                                            </span>
                                            <div class="d-flex gap-2">
                                                <button
                                                    class="btn btn-link btn-sm p-0"
                                                    v-if="getLogState(job['JOBID']).hasPrev"
                                                    :disabled="getLogState(job['JOBID']).loadingPrev"
                                                    @click="loadMoreLog(job['JOBID'], 'prev')"
                                                >
                                                    Load previous
                                                </button>
                                                <button
                                                    class="btn btn-link btn-sm p-0"
                                                    v-if="getLogState(job['JOBID']).hasNext"
                                                    :disabled="getLogState(job['JOBID']).loadingNext"
                                                    @click="loadMoreLog(job['JOBID'], 'next')"
                                                >
                                                    Load next
                                                </button>
                                                <button
                                                    class="btn btn-link btn-sm p-0"
                                                    @click="scrollToLogTop(job['JOBID'])"
                                                >
                                                    Go to top
                                                </button>
                                            </div>
                                        </div>
                                        <div v-if="getLogState(job['JOBID']).error" class="alert alert-warning py-2">
                                            {{ getLogState(job['JOBID']).error }}
                                        </div>
                                        <div class="log-output-wrapper">
                                            <div
                                                :ref="`log-output-${job['JOBID']}`"
                                                class="log-output"
                                                @scroll="handleLogScroll(job['JOBID'], $event)"
                                            >
                                                <div :style="{height: getLogSpacer(job['JOBID']).top + 'px'}"></div>
                                                <pre class="log-chunk">{{ getLogText(job['JOBID']) || 'No log output yet.' }}</pre>
                                                <div :style="{height: getLogSpacer(job['JOBID']).bottom + 'px'}"></div>
                                            </div>
                                        </div>
                                    </div>
                                </td>
                            </tr>
                            <tr v-if="job && job['JOBID'] && getScriptState(job['JOBID']).visible">
                                <td colspan="12">
                                    <div class="log-container">
                                        <div class="log-toolbar">
                                            <div>
                                                <strong>Script for job {{ job['JOBID'] }}</strong>
                                            </div>
                                            <div class="d-flex align-items-center gap-3 flex-wrap justify-content-end">
                                                <div v-if="getScriptState(job['JOBID']).loading" class="text-warning">
                                                    <span class="spinner-border spinner-border-sm" role="status"></span>
                                                    <span class="ms-2">Loading…</span>
                                                </div>
                                                <small v-else-if="getScriptState(job['JOBID']).lastFetched" class="text-muted">
                                                    Fetched: {{ getScriptState(job['JOBID']).lastFetched }}
                                                </small>
                                                <button class="btn btn-sm btn-outline-light" @click="refreshScript(job['JOBID'])">
                                                    Refresh script
                                                </button>
                                            </div>
                                        </div>
                                        <div v-if="getScriptState(job['JOBID']).error" class="alert alert-warning py-2">
                                            {{ getScriptState(job['JOBID']).error }}
                                        </div>
                                        <div class="log-output-wrapper">
                                            <pre class="log-output">{{ getScriptState(job['JOBID']).content || 'Script not available.' }}</pre>
                                        </div>
                                    </div>
                                </td>
                            </tr>
                            <tr v-if="job && job['JOBID'] && getInfoState(job['JOBID']).visible">
                                <td colspan="12">
                                    <div class="log-container">
                                        <div class="log-toolbar">
                                            <div>
                                                <strong>Info for job {{ job['JOBID'] }}</strong>
                                            </div>
                                            <div class="d-flex align-items-center gap-3 flex-wrap justify-content-end">
                                                <div v-if="getInfoState(job['JOBID']).loading" class="text-warning">
                                                    <span class="spinner-border spinner-border-sm" role="status"></span>
                                                    <span class="ms-2">Loading…</span>
                                                </div>
                                                <small v-else-if="getInfoState(job['JOBID']).lastFetched" class="text-muted">
                                                    Fetched: {{ getInfoState(job['JOBID']).lastFetched }}
                                                </small>
                                                <button class="btn btn-sm btn-outline-light" @click="refreshInfo(job['JOBID'])">
                                                    Refresh info
                                                </button>
                                            </div>
                                        </div>
                                        <div v-if="getInfoState(job['JOBID']).error" class="alert alert-warning py-2">
                                            {{ getInfoState(job['JOBID']).error }}
                                        </div>
                                        <div v-if="hasInfoDetails(job['JOBID'])" class="table-responsive mb-3">
                                            <table class="table table-sm table-striped info-table mb-0">
                                                <tbody>
                                                    <tr v-for="detail in getInfoDetails(job['JOBID'])" :key="detail.key">
                                                        <td class="fw-semibold text-uppercase text-muted" style="width: 200px;">
                                                            {{ detail.key }}
                                                        </td>
                                                        <td>{{ detail.value }}</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                        <div class="log-output-wrapper mt-3">
                                            <pre class="log-output">{{ getInfoState(job['JOBID']).content || 'Job info not available.' }}</pre>
                                        </div>
                                    </div>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>

            <div class="mt-3 text-muted text-center">
                <small>Total jobs: {{ jobs.length }}</small>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    jobs: [],
                    loading: false,
                    error: null,
                    lastUpdate: null,
                    pollInterval: null,
                    statusMessage: null,
                    cancelingJobs: {},
                    logStates: {},
                    logIntervals: {},
                    logAutoScroll: {},
                    logUserScrolled: {},
                    commentEditors: {},
                    commentDrafts: {},
                    commentSaving: {},
                    scriptStates: {},
                    infoStates: {},
                    searchQuery: '',
                    searchResults: [],
                    searchLoading: false,
                    searchError: null,
                    searchLogState: {
                        visible: false,
                        path: null,
                        pathRelative: null,
                        loading: false,
                        error: null,
                        sizeBytes: null,
                        chunks: [],
                        hasPrev: false,
                        hasNext: false,
                        prevStart: null,
                        nextStart: null,
                        chunkBytes: 200000,
                        start: null,
                        end: null,
                        shownBytes: null,
                        jobId: null,
                        jobComment: ''
                    },
                    outputDir: '',
                    searchDebounce: null,
                    defaultChunkBytes: 200000,
                    maxChunkBytes: 1000000,
                    logJumpingTop: {},
                    searchJumpingTop: false,
                    failedVisible: false,
                    failedLoading: false,
                    failedJobs: [],
                    failedError: null,
                    failedLastFetched: null,
                    failedHours: 72,
                    completedVisible: false,
                    completedLoading: false,
                    completedJobs: [],
                    completedError: null,
                    completedLastFetched: null,
                    completedHours: 72
                };
            },
            mounted() {
                this.fetchConfig();
                this.fetchJobs();
                // Poll every 2 seconds
                this.pollInterval = setInterval(() => {
                    this.fetchJobs();
                }, 2000);
            },
            beforeUnmount() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                }
                Object.values(this.logIntervals).forEach(intervalId => {
                    if (intervalId) {
                        clearInterval(intervalId);
                    }
                });
            },
            methods: {
                onSearchInput() {
                    this.searchError = null;
                    if (this.searchQuery.trim().length === 0) {
                        this.searchResults = [];
                        this.closeSearchLog();
                        return;
                    }
                    clearTimeout(this.searchDebounce);
                    this.searchDebounce = setTimeout(() => {
                        this.searchLogs();
                    }, 400);
                },
                async searchLogs() {
                    const query = this.searchQuery.trim();
                    if (!query) {
                        this.searchResults = [];
                        this.closeSearchLog();
                        return;
                    }
                    this.searchLoading = true;
                    this.searchError = null;
                    try {
                        const response = await fetch(`/api/logs/search?q=${encodeURIComponent(query)}`);
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.message || 'Search failed');
                        }
                        this.searchResults = data.results || [];
                        if (this.searchResults.length === 1) {
                            this.openSearchResult(this.searchResults[0]);
                        } else {
                            this.closeSearchLog();
                        }
                    } catch (error) {
                        this.searchError = error.message || 'Search failed';
                    } finally {
                        this.searchLoading = false;
                    }
                },
                clearSearch() {
                    if (this.searchDebounce) {
                        clearTimeout(this.searchDebounce);
                        this.searchDebounce = null;
                    }
                    this.searchQuery = '';
                    this.searchResults = [];
                    this.searchError = null;
                    this.closeSearchLog();
                },
                toggleCompletedJobs() {
                    this.completedVisible = !this.completedVisible;
                    if (this.completedVisible && !this.completedJobs.length) {
                        this.fetchCompletedJobs();
                    }
                },
                async fetchCompletedJobs() {
                    if (!this.completedVisible) {
                        this.completedVisible = true;
                    }
                    this.completedLoading = true;
                    this.completedError = null;
                    try {
                        const params = new URLSearchParams();
                        if (this.completedHours) {
                            params.append('hours', this.completedHours);
                        }
                        params.append('limit', 30);
                        const response = await fetch(`/api/jobs/completed?${params.toString()}`);
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.message || 'Failed to fetch completed jobs');
                        }
                        this.completedJobs = data.jobs || [];
                        this.completedLastFetched = new Date().toLocaleTimeString();
                    } catch (error) {
                        this.completedError = error.message || 'Failed to fetch completed jobs';
                    } finally {
                        this.completedLoading = false;
                    }
                },
                toggleFailedJobs() {
                    this.failedVisible = !this.failedVisible;
                    if (this.failedVisible && !this.failedJobs.length) {
                        this.fetchFailedJobs();
                    }
                },
                async fetchFailedJobs() {
                    if (!this.failedVisible) {
                        this.failedVisible = true;
                    }
                    this.failedLoading = true;
                    this.failedError = null;
                    try {
                        const params = new URLSearchParams();
                        if (this.failedHours) {
                            params.append('hours', this.failedHours);
                        }
                        params.append('limit', 30);
                        const response = await fetch(`/api/jobs/failed?${params.toString()}`);
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.message || 'Failed to fetch failed jobs');
                        }
                        this.failedJobs = data.jobs || [];
                        this.failedLastFetched = new Date().toLocaleTimeString();
                    } catch (error) {
                        this.failedError = error.message || 'Failed to fetch failed jobs';
                    } finally {
                        this.failedLoading = false;
                    }
                },
                async fetchConfig() {
                    try {
                        const response = await fetch('/api/config');
                        const data = await response.json();
                        if (response.ok && data.log_dir) {
                            this.outputDir = data.log_dir;
                        } else {
                            this.outputDir = '';
                            if (data.log_dir_error) {
                                this.searchError = data.log_dir_error;
                            }
                        }
                    } catch (e) {
                        this.outputDir = '';
                    }
                },
                async fetchJobs() {
                    this.loading = true;
                    this.error = null;
                    try {
                        const response = await fetch('/api/jobs');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        this.jobs = data;
                        this.lastUpdate = new Date().toLocaleTimeString();
                    } catch (error) {
                        this.error = `Failed to fetch jobs: ${error.message}`;
                        console.error('Error fetching jobs:', error);
                    } finally {
                        this.loading = false;
                    }
                },
                getStatusBadgeClass(status) {
                    const statusUpper = (status || '').toUpperCase();
                    if (statusUpper.includes('RUNNING')) {
                        return 'bg-success';
                    } else if (statusUpper.includes('PENDING')) {
                        return 'bg-warning text-dark';
                    } else if (statusUpper.includes('COMPLETED')) {
                        return 'bg-info';
                    } else if (statusUpper.includes('FAILED') || statusUpper.includes('CANCELLED')) {
                        return 'bg-danger';
                    } else {
                        return 'bg-secondary';
                    }
                },
                canCancel(job) {
                    if (!job) return false;
                    const state = (job['STATE'] || '').toUpperCase();
                    return ['PENDING', 'CONFIGURING', 'RUNNING', 'COMPLETING'].some(status =>
                        state.includes(status)
                    );
                },
                async cancelJob(job) {
                    if (!job) return;
                    const jobId = job['JOBID'];
                    if (!jobId || !this.canCancel(job)) {
                        return;
                    }
                    const confirmed = window.confirm(`Cancel job ${jobId}?`);
                    if (!confirmed) {
                        return;
                    }

                    this.error = null;
                    this.statusMessage = null;
                    this.cancelingJobs = { ...this.cancelingJobs, [jobId]: true };

                    try {
                        const response = await fetch(`/api/jobs/${jobId}/cancel`, {
                            method: 'POST'
                        });
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.message || 'Failed to cancel job');
                        }
                        this.statusMessage = `Job ${jobId} cancellation requested`;
                        this.fetchJobs();
                    } catch (error) {
                        this.error = `Failed to cancel job ${jobId}: ${error.message}`;
                        console.error(error);
                    } finally {
                        const updated = { ...this.cancelingJobs };
                        delete updated[jobId];
                        this.cancelingJobs = updated;
                    }
                },
                isEditingComment(jobId) {
                    return !!this.commentEditors[jobId];
                },
                startEditingComment(job) {
                    if (!job || !job['JOBID']) return;
                    const jobId = job['JOBID'];
                    this.commentEditors = { ...this.commentEditors, [jobId]: true };
                    this.commentDrafts = {
                        ...this.commentDrafts,
                        [jobId]: job['comment'] || ''
                    };
                },
                cancelEditingComment(jobId) {
                    if (!jobId) return;
                    const editors = { ...this.commentEditors };
                    const drafts = { ...this.commentDrafts };
                    delete editors[jobId];
                    delete drafts[jobId];
                    this.commentEditors = editors;
                    this.commentDrafts = drafts;
                },
                async saveComment(job) {
                    if (!job || !job['JOBID']) return;
                    const jobId = job['JOBID'];
                    const comment = (this.commentDrafts[jobId] || '').trim();

                    this.commentSaving = { ...this.commentSaving, [jobId]: true };
                    this.error = null;
                    try {
                        const response = await fetch(`/api/jobs/${jobId}/comment`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ comment })
                        });
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.message || 'Failed to save comment');
                        }
                        job['comment'] = data.comment || '';
                        this.cancelEditingComment(jobId);
                    } catch (error) {
                        this.error = `Failed to save comment for job ${jobId}: ${error.message}`;
                    } finally {
                        const saving = { ...this.commentSaving };
                        delete saving[jobId];
                        this.commentSaving = saving;
                    }
                },
                toggleLog(job) {
                    if (!job) return;
                    const jobId = job['JOBID'];
                    if (!jobId) {
                        return;
                    }
                    const state = this.getLogState(jobId);
                    if (state.visible) {
                        this.hideLog(jobId);
                    } else {
                        this.showLog(jobId);
                    }
                },
                showLog(jobId) {
                    const id = String(jobId);
                    this.hidePanelsOfType('log', id);
                    this.updateLogState(id, {
                        visible: true,
                        loading: true,
                        error: null
                    });
                    // Enable auto-scroll by default
                    this.logAutoScroll = { ...this.logAutoScroll, [id]: true };
                    this.logUserScrolled = { ...this.logUserScrolled, [id]: false };
                    this.refreshLog(id);
                    this.clearLogInterval(id);
                    const interval = setInterval(() => {
                        this.refreshLog(id, true);
                    }, 2000);
                    this.logIntervals = { ...this.logIntervals, [id]: interval };
                    // Scroll to bottom after a short delay to ensure DOM is updated
                    this.$nextTick(() => {
                        setTimeout(() => this.scrollLogToBottom(id), 100);
                    });
                },
                hideLog(jobId) {
                    const id = String(jobId);
                    this.clearLogInterval(id);
                    this.updateLogState(id, {
                        visible: false,
                        chunks: []
                    });
                    // Clean up scroll state
                    const autoScroll = { ...this.logAutoScroll };
                    const userScrolled = { ...this.logUserScrolled };
                    delete autoScroll[id];
                    delete userScrolled[id];
                    this.logAutoScroll = autoScroll;
                    this.logUserScrolled = userScrolled;
                },
                hidePanelsOfType(type, jobId) {
                    const target = String(jobId);
                    let states;
                    let hideFn;
                    if (type === 'log') {
                        states = this.logStates;
                        hideFn = this.hideLog;
                    } else if (type === 'script') {
                        states = this.scriptStates;
                        hideFn = this.hideScript;
                    } else if (type === 'info') {
                        states = this.infoStates;
                        hideFn = this.hideInfo;
                    } else {
                        return;
                    }
                    Object.keys(states).forEach(id => {
                        const state = states[id];
                        if (id !== target && state && state.visible) {
                            hideFn(id);
                        }
                    });
                },
                toggleScript(job) {
                    if (!job) return;
                    const jobId = job['JOBID'];
                    if (!jobId) return;
                    const state = this.getScriptState(jobId);
                    if (state.visible) {
                        this.hideScript(jobId);
                    } else {
                        this.showScript(jobId);
                    }
                },
                showScript(jobId) {
                    const id = String(jobId);
                    this.hidePanelsOfType('script', id);
                    this.updateScriptState(id, {
                        visible: true,
                        loading: true,
                        error: null
                    });
                    this.fetchScript(id);
                },
                hideScript(jobId) {
                    const id = String(jobId);
                    this.updateScriptState(id, {
                        visible: false
                    });
                },
                async fetchScript(jobId) {
                    if (!jobId) return;
                    const id = String(jobId);
                    this.updateScriptState(id, { loading: true, error: null });
                    try {
                        const response = await fetch(`/api/jobs/${id}/script`);
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.script || data.message || 'Unable to load script');
                        }
                        this.updateScriptState(id, {
                            content: data.script || '',
                            error: null,
                            loading: false,
                            lastFetched: new Date().toLocaleTimeString()
                        });
                    } catch (error) {
                        this.updateScriptState(id, {
                            error: error.message || 'Unable to load script',
                            loading: false
                        });
                    }
                },
                refreshScript(jobId) {
                    this.fetchScript(jobId);
                },
                toggleInfo(job) {
                    if (!job) return;
                    const jobId = job['JOBID'];
                    if (!jobId) return;
                    const state = this.getInfoState(jobId);
                    if (state.visible) {
                        this.hideInfo(jobId);
                    } else {
                        this.showInfo(jobId);
                    }
                },
                showInfo(jobId) {
                    const id = String(jobId);
                    this.hidePanelsOfType('info', id);
                    this.updateInfoState(id, {
                        visible: true,
                        loading: true,
                        error: null
                    });
                    this.fetchInfo(id);
                },
                hideInfo(jobId) {
                    const id = String(jobId);
                    this.updateInfoState(id, {
                        visible: false
                    });
                },
                async fetchInfo(jobId) {
                    if (!jobId) return;
                    const id = String(jobId);
                    this.updateInfoState(id, { loading: true, error: null });
                    try {
                        const response = await fetch(`/api/jobs/${id}/info`);
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.info || data.message || 'Unable to load info');
                        }
                        this.updateInfoState(id, {
                            content: data.info || '',
                            details: data.details || {},
                            error: null,
                            loading: false,
                            lastFetched: new Date().toLocaleTimeString()
                        });
                    } catch (error) {
                        this.updateInfoState(id, {
                            error: error.message || 'Unable to load info',
                            loading: false
                        });
                    }
                },
                refreshInfo(jobId) {
                    this.fetchInfo(jobId);
                },
                clearLogInterval(jobId) {
                    const id = String(jobId);
                    const existing = this.logIntervals[id];
                    if (existing) {
                        clearInterval(existing);
                        const updatedIntervals = { ...this.logIntervals };
                        delete updatedIntervals[id];
                        this.logIntervals = updatedIntervals;
                    }
                },
                async refreshLog(jobId, start = null) {
                    if (!jobId) return;
                    const id = String(jobId);
                    const elRef = this.$refs[`log-output-${id}`];
                    const scrollEl = Array.isArray(elRef) ? elRef[0] : elRef;
                    await this.fetchLogChunk(id, { start, mode: 'replace', scrollEl });
                },
                async fetchLogChunk(jobId, { start = null, mode = 'replace', scrollEl = null } = {}) {
                    const id = String(jobId);
                    const state = this.getLogState(id);
                    const chunkSize = state.chunkBytes || this.defaultChunkBytes;
                    const params = new URLSearchParams();
                    if (start !== null && start !== undefined) {
                        params.append('start', start);
                    }
                    params.append('length', chunkSize);
                    if (mode === 'replace') {
                        this.updateLogState(id, { loading: true, error: null });
                    } else if (mode === 'prepend') {
                        this.updateLogState(id, { loadingPrev: true, error: null });
                    } else if (mode === 'append') {
                        this.updateLogState(id, { loadingNext: true, error: null });
                    }
                    const prevHeight = scrollEl ? scrollEl.scrollHeight : null;
                    const prevScrollTop = scrollEl ? scrollEl.scrollTop : null;
                    try {
                        const response = await fetch(`/api/jobs/${id}/log?${params.toString()}`);
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.message || 'Failed to load log');
                        }
                        const chunk = {
                            start: data.start,
                            end: data.end,
                            content: data.log || ''
                        };
                        let chunks = state.chunks ? [...state.chunks] : [];
                        if (mode === 'replace') {
                            chunks = [chunk];
                        } else if (mode === 'prepend') {
                            chunks = [chunk, ...chunks];
                            if (chunks.length > 3) {
                                chunks = chunks.slice(0, 3);
                            }
                        } else if (mode === 'append') {
                            chunks = [...chunks, chunk];
                            if (chunks.length > 3) {
                                chunks = chunks.slice(-3);
                            }
                        }
                        this.updateLogState(id, {
                            loading: false,
                            loadingPrev: false,
                            loadingNext: false,
                            chunks,
                            path: data.path || state.path,
                            sizeBytes: data.size_bytes ?? state.sizeBytes,
                            hasPrev: data.has_prev,
                            hasNext: data.has_next,
                            prevStart: data.prev_start,
                            nextStart: data.next_start,
                            chunkBytes: data.chunk_bytes || chunkSize,
                            start: chunks.length ? chunks[0].start : null,
                            end: chunks.length ? chunks[chunks.length - 1].end : null,
                            lastFetched: new Date().toLocaleTimeString()
                        });
                        if (mode === 'prepend' && scrollEl && prevHeight !== null) {
                            this.$nextTick(() => {
                                const newHeight = scrollEl.scrollHeight;
                                scrollEl.scrollTop = (scrollEl.scrollTop || 0) + (newHeight - prevHeight);
                            });
                        } else if (mode === 'replace' && scrollEl) {
                            this.$nextTick(() => {
                                scrollEl.scrollTop = scrollEl.scrollHeight;
                            });
                        } else if (mode === 'append' && scrollEl && prevScrollTop !== null) {
                            this.$nextTick(() => {
                                scrollEl.scrollTop = prevScrollTop;
                            });
                        }
                    } catch (error) {
                        this.updateLogState(id, {
                            loading: false,
                            loadingPrev: false,
                            loadingNext: false,
                            error: error.message || 'Failed to load log'
                        });
                    }
                },
                loadMoreLog(jobId, direction) {
                    const id = String(jobId);
                    const state = this.getLogState(id);
                    if (state.loading || state.loadingPrev || state.loadingNext) {
                        return;
                    }
                    const elRef = this.$refs[`log-output-${id}`];
                    const scrollEl = Array.isArray(elRef) ? elRef[0] : elRef;
                     if (!scrollEl) return;
                    if (direction === 'prev' && state.hasPrev && state.prevStart !== null) {
                        this.fetchLogChunk(id, { start: state.prevStart, mode: 'prepend', scrollEl });
                    } else if (direction === 'next' && state.hasNext && state.nextStart !== null) {
                        this.fetchLogChunk(id, { start: state.nextStart, mode: 'append', scrollEl });
                    }
                },
                async fetchSearchLogChunk(relativePath, { start = null, mode = 'replace' } = {}) {
                    if (!relativePath) return;
                    const chunkSize = this.searchLogState.chunkBytes || this.defaultChunkBytes;
                    const params = new URLSearchParams();
                    params.append('path', relativePath);
                    if (start !== null && start !== undefined) {
                        params.append('start', start);
                    }
                    params.append('length', chunkSize);
                    this.searchLogState = {
                        ...this.searchLogState,
                        visible: true,
                        loading: true,
                        error: null
                    };
                    try {
                        const response = await fetch(`/api/logs/view?${params.toString()}`);
                        const data = await response.json();
                        if (!response.ok || !data.success) {
                            throw new Error(data.message || 'Unable to load log');
                        }
                        const chunk = {
                            start: data.start,
                            end: data.end,
                            content: data.content || ''
                        };
                        let chunks = this.searchLogState.chunks ? [...this.searchLogState.chunks] : [];
                        if (mode === 'replace') {
                            chunks = [chunk];
                        } else if (mode === 'prepend') {
                            chunks = [chunk, ...chunks];
                            if (chunks.length > 3) {
                                chunks = chunks.slice(0, 3);
                            }
                        } else if (mode === 'append') {
                            chunks = [...chunks, chunk];
                            if (chunks.length > 3) {
                                chunks = chunks.slice(-3);
                            }
                        }
                        this.searchLogState = {
                            ...this.searchLogState,
                            loading: false,
                            error: null,
                            chunks,
                            path: data.path,
                            pathRelative: relativePath,
                            sizeBytes: data.size_bytes ?? this.searchLogState.sizeBytes,
                            hasPrev: data.has_prev,
                            hasNext: data.has_next,
                            prevStart: data.prev_start,
                            nextStart: data.next_start,
                            start: chunks.length ? chunks[0].start : null,
                            end: chunks.length ? chunks[chunks.length - 1].end : null,
                            shownBytes: (chunks.length ? chunks[chunks.length - 1].end : 0) - (chunks.length ? chunks[0].start : 0),
                            chunkBytes: chunkSize
                        };
                    } catch (error) {
                        this.searchLogState = {
                            ...this.searchLogState,
                            loading: false,
                            error: error.message || 'Unable to load log'
                        };
                    }
                },
                loadMoreSearchLog(direction) {
                    const rel = this.searchLogState.pathRelative;
                    if (!this.searchLogState.visible || !rel || this.searchLogState.loading) return;
                    if (direction === 'prev' && this.searchLogState.hasPrev && this.searchLogState.prevStart !== null) {
                        this.fetchSearchLogChunk(rel, { start: this.searchLogState.prevStart, mode: 'prepend' });
                    } else if (direction === 'next' && this.searchLogState.hasNext && this.searchLogState.nextStart !== null) {
                        this.fetchSearchLogChunk(rel, { start: this.searchLogState.nextStart, mode: 'append' });
                    }
                },
                scrollLogToBottom(jobId) {
                    // Vue 3 refs: when using dynamic refs in v-for, they're stored as arrays
                    const refKey = `log-output-${jobId}`;
                    const logElement = this.$refs[refKey];
                    if (logElement) {
                        // Handle both array (from v-for) and single element cases
                        const element = Array.isArray(logElement) ? logElement[0] : logElement;
                        if (element) {
                            element.scrollTop = element.scrollHeight;
                        }
                    }
                },
                handleLogScroll(jobId, event) {
                    if (this.logJumpingTop[jobId]) {
                        return;
                    }
                    const element = event.target;
                    const threshold = 200;
                    const nearTop = element.scrollTop <= threshold;
                    const nearBottom = element.scrollHeight - (element.scrollTop + element.clientHeight) <= threshold;
                    if (nearBottom) {
                        this.logAutoScroll = { ...this.logAutoScroll, [jobId]: true };
                        this.logUserScrolled = { ...this.logUserScrolled, [jobId]: false };
                        this.loadMoreLog(jobId, 'next');
                    } else {
                        this.logUserScrolled = { ...this.logUserScrolled, [jobId]: true };
                        if (nearTop) {
                            this.loadMoreLog(jobId, 'prev');
                        }
                    }
                },
                async scrollToLogTop(jobId) {
                    if (!jobId) return;
                    const id = String(jobId);
                    const elRef = this.$refs[`log-output-${id}`];
                    const scrollEl = Array.isArray(elRef) ? elRef[0] : elRef;
                    this.logJumpingTop = { ...this.logJumpingTop, [id]: true };
                    await this.fetchLogChunk(id, { start: 0, mode: 'replace', scrollEl: null });
                    this.$nextTick(() => {
                        if (scrollEl) {
                            scrollEl.scrollTop = 0;
                        }
                        const updated = { ...this.logJumpingTop };
                        delete updated[id];
                        this.logJumpingTop = updated;
                    });
                },
                handleSearchLogScroll(event) {
                    if (!this.searchLogState.visible || this.searchLogState.loading || this.searchJumpingTop) return;
                    const element = event.target;
                    const threshold = 200;
                    const nearTop = element.scrollTop <= threshold;
                    const nearBottom = element.scrollHeight - (element.scrollTop + element.clientHeight) <= threshold;
                    if (nearTop) {
                        this.loadMoreSearchLog('prev');
                    } else if (nearBottom) {
                        this.loadMoreSearchLog('next');
                    }
                },
                async scrollToSearchTop() {
                    const rel = this.searchLogState.pathRelative;
                    if (!rel) return;
                    this.searchJumpingTop = true;
                    await this.fetchSearchLogChunk(rel, { start: 0, mode: 'replace' });
                    this.$nextTick(() => {
                        const el = this.$refs.searchLogOutput;
                        if (el) {
                            el.scrollTop = 0;
                        }
                        this.searchJumpingTop = false;
                    });
                },
                getLogState(jobId) {
                    return this.logStates[jobId] || {
                        visible: false,
                        loading: false,
                        error: null,
                        chunks: [],
                        sizeBytes: null,
                        hasPrev: false,
                        hasNext: false,
                        prevStart: null,
                        nextStart: null,
                        chunkBytes: this.defaultChunkBytes,
                        start: null,
                        end: null
                    };
                },
                updateLogState(jobId, updates) {
                    const existing = this.logStates[jobId] || {
                        visible: false,
                        loading: false,
                        error: null,
                        chunks: [],
                        path: null,
                        lastFetched: null,
                        sizeBytes: null,
                        hasPrev: false,
                        hasNext: false,
                        prevStart: null,
                        nextStart: null,
                        chunkBytes: this.defaultChunkBytes,
                        start: null,
                        end: null
                    };
                    this.logStates = {
                        ...this.logStates,
                        [jobId]: {
                            ...existing,
                            ...updates
                        }
                    };
                },
                getScriptState(jobId) {
                    return this.scriptStates[String(jobId)] || { visible: false };
                },
                updateScriptState(jobId, updates) {
                    const id = String(jobId);
                    const existing = this.scriptStates[id] || {
                        visible: false,
                        loading: false,
                        error: null,
                        content: '',
                        lastFetched: null
                    };
                    this.scriptStates = {
                        ...this.scriptStates,
                        [id]: {
                            ...existing,
                            ...updates
                        }
                    };
                },
                getInfoState(jobId) {
                    return this.infoStates[String(jobId)] || { visible: false };
                },
                updateInfoState(jobId, updates) {
                    const id = String(jobId);
                    const existing = this.infoStates[id] || {
                        visible: false,
                        loading: false,
                        error: null,
                        content: '',
                        lastFetched: null,
                        details: {}
                    };
                    this.infoStates = {
                        ...this.infoStates,
                        [id]: {
                            ...existing,
                            ...updates
                        }
                    };
                },
                hasInfoDetails(jobId) {
                    const state = this.getInfoState(jobId);
                    return state.details && Object.keys(state.details).length > 0;
                },
                getInfoDetails(jobId) {
                    const state = this.getInfoState(jobId);
                    if (!state.details) {
                        return [];
                    }
                    return Object.entries(state.details).map(([key, value]) => ({
                        key,
                        value
                    }));
                },
                formatBytes(size) {
                    if (size === null || size === undefined) {
                        return '';
                    }
                    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                    let idx = 0;
                    let value = size;
                    while (value >= 1024 && idx < units.length - 1) {
                        value /= 1024;
                        idx += 1;
                    }
                    return `${value.toFixed(value >= 10 || idx === 0 ? 0 : 1)} ${units[idx]}`;
                },
                formatDate(value) {
                    if (!value) return '';
                    try {
                        return new Date(value).toLocaleString();
                    } catch (e) {
                        return value;
                    }
                },
                getResultFullPath(result) {
                    if (!result) return '';
                    if (result.path) return result.path;
                    if (result.relative_path) {
                        if (this.outputDir) {
                            return `${this.outputDir.replace(/\/$/, '')}/${result.relative_path}`;
                        }
                        return result.relative_path;
                    }
                    return '';
                },
                getLogText(jobId) {
                    const state = this.getLogState(jobId);
                    if (state.chunks && state.chunks.length) {
                        return state.chunks.map(chunk => chunk.content).join('');
                    }
                    return '';
                },
                getLogSpacer(jobId) {
                    const state = this.getLogState(jobId);
                    const size = state.sizeBytes || state.end || state.chunkBytes || this.defaultChunkBytes;
                    const start = state.start || 0;
                    const end = state.end || start;
                    const pxPerByte = size > 0 ? Math.min(0.1, 4000 / size) : 0.05;
                    return {
                        top: Math.max(start * pxPerByte, 0),
                        bottom: Math.max((size - end) * pxPerByte, 0)
                    };
                },
                getLogRange(jobId) {
                    const state = this.getLogState(jobId);
                    if (!state.chunks || !state.chunks.length) return null;
                    const start = state.chunks[0].start;
                    const end = state.chunks[state.chunks.length - 1].end;
                    return {
                        start,
                        end,
                        shown: end - start,
                        size: state.sizeBytes || null,
                        hasPrev: state.hasPrev,
                        hasNext: state.hasNext
                    };
                },
                getSearchLogText() {
                    if (this.searchLogState.chunks && this.searchLogState.chunks.length) {
                        return this.searchLogState.chunks.map(chunk => chunk.content).join('');
                    }
                    return '';
                },
                getSearchSpacer() {
                    const state = this.searchLogState;
                    const size = state.sizeBytes || state.end || state.chunkBytes || this.defaultChunkBytes;
                    const start = state.start || 0;
                    const end = state.end || start;
                    const pxPerByte = size > 0 ? Math.min(0.1, 4000 / size) : 0.05;
                    return {
                        top: Math.max(start * pxPerByte, 0),
                        bottom: Math.max((size - end) * pxPerByte, 0)
                    };
                },
                getSearchLogRange() {
                    if (!this.searchLogState.chunks || !this.searchLogState.chunks.length) return null;
                    const start = this.searchLogState.chunks[0].start;
                    const end = this.searchLogState.chunks[this.searchLogState.chunks.length - 1].end;
                    return {
                        start,
                        end,
                        shown: end - start,
                        size: this.searchLogState.sizeBytes || null,
                        hasPrev: this.searchLogState.hasPrev,
                        hasNext: this.searchLogState.hasNext
                    };
                },
                async openSearchResult(result) {
                    if (!result || !result.relative_path) return;
                    this.searchLogState = {
                        ...this.searchLogState,
                        visible: true,
                        pathRelative: result.relative_path,
                        jobId: result.job_id || null,
                        jobComment: result.comment || '',
                        chunks: []
                    };
                    await this.fetchSearchLogChunk(result.relative_path, { start: null, mode: 'replace' });
                },
                closeSearchLog() {
                    this.searchLogState = {
                        visible: false,
                        path: null,
                        pathRelative: null,
                        loading: false,
                        error: null,
                        sizeBytes: null,
                        chunks: [],
                        hasPrev: false,
                        hasNext: false,
                        prevStart: null,
                        nextStart: null,
                        start: null,
                        end: null,
                        shownBytes: null,
                        chunkBytes: this.defaultChunkBytes,
                        jobId: null,
                        jobComment: ''
                    };
                }
            }
        }).mount('#app');
    </script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

